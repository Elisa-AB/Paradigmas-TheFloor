Object subclass: #Juego	instanceVariableNames: 'jugadores tablero temas actualJugador ganador respuestaSeleccionada'	classVariableNames: ''	poolDictionaries: ''	category: 'Juego-thefloor'!!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:39'!procesarGanadorManual: winner ventana: ventana	"Procesa el resultado del duelo cuando el ganador es asignado manualmente para fines de desarrollo"	UIManager default inform: 'El ganador del duelo es ', winner nombre, '!!'.	self asignarTerritorioDe: (winner = actualJugador ifTrue: [jugadores at: 2] ifFalse: [actualJugador]) a: winner.	ventana delete.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:25'!verificarGanador	"Determina si hay un ganador (solo queda un jugador)"	(jugadores size = 1) ifTrue: [ganador := jugadores first].! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:24'!dueloEntre: jugador1 y: jugador2	"Ejemplo de duelo donde se elige un ganador manualmente"	| ganadorDuelo |	ganadorDuelo := UIManager default 		chooseFrom: {jugador1 nombre. jugador2 nombre} 		title: '¿Quién ganó el duelo?'.	(ganadorDuelo = jugador1 nombre) 		ifTrue: [self asignarTerritorioDe: jugador2 a: jugador1]		ifFalse: [self asignarTerritorioDe: jugador1 a: jugador2].! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:23'!asignarTerritorios	"Asignar posiciones iniciales a cada jugador en el tablero"	| posicionesLibres posicionInicial |	posicionesLibres := OrderedCollection new.	1 to: 4 do: [:fila |		1 to: 4 do: [:columna |			posicionesLibres add: (Array with: fila with: columna).		].	].	jugadores do: [:jugador | 		posicionInicial := posicionesLibres atRandom.		jugador asignarTerritorio: posicionInicial.		posicionesLibres remove: posicionInicial.		UIManager default inform: jugador nombre , ' ha sido asignado al territorio ', posicionInicial printString.	].! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:22'!asignarTemas	"Asignar un tema aleatorio a cada jugador de los temas disponibles en Pregunta preguntasDisponibles"	temas := Pregunta preguntasDisponibles keys collect: [:nombreTema | Tema nuevoTemaConNombre: nombreTema].	jugadores do: [:jugador | 		| temaAleatorio |		temaAleatorio := temas atRandom.		jugador asignarTema: temaAleatorio.		UIManager default inform: jugador nombre , ' ha recibido el tema: ', temaAleatorio nombre.	].! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:24'!siguienteTurno	"Realiza las acciones del turno del jugador actual"	actualJugador := jugadores atRandom.	UIManager default inform: 'Es el turno de ', actualJugador nombre.	self elegirContrincante.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:45'!interfazDeDueloEntre: jugador1 y: jugador2	| ventana preguntaActual preguntaLabel opcion1 opcion2 opcion3 opcion4 botonGanador1 botonGanador2 opcionesRespuestas |	"Obtener una pregunta aleatoria del tema del jugador actual"	preguntaActual := jugador1 tema preguntaAleatoria.		"Crear la ventana gráfica para el duelo"	ventana := SystemWindow labelled: 'Duelo: ', jugador1 nombre, ' vs ', jugador2 nombre.	ventana extent: 400@300.	"Mostrar la pregunta en la parte superior"	preguntaLabel := TextMorph new contents: preguntaActual texto.	preguntaLabel position: 20@20.	ventana addMorph: preguntaLabel.	"Obtener opciones de respuesta (respuestas incorrectas y la correcta)"	opcionesRespuestas := (preguntaActual respuestasIncorrectas copyWith: preguntaActual respuestaCorrecta) shuffled.	"Agregar opciones de respuesta (tipo multiple choice) con botones de selección"	opcion1 := SimpleButtonMorph new label: (opcionesRespuestas at: 1);		position: 20@60.	opcion1 on: #mouseUp send: #seleccionarRespuesta: to: self.	opcion1 arguments: {(opcionesRespuestas at: 1)}.	ventana addMorph: opcion1.	opcion2 := SimpleButtonMorph new label: (opcionesRespuestas at: 2);		position: 120@60.	opcion2 on: #mouseUp send: #seleccionarRespuesta: to: self.	opcion2 arguments: {(opcionesRespuestas at: 2)}.	ventana addMorph: opcion2.	opcion3 := SimpleButtonMorph new label: (opcionesRespuestas at: 3);		position: 220@60.	opcion3 on: #mouseUp send: #seleccionarRespuesta: to: self.	opcion3 arguments: {(opcionesRespuestas at: 3)}.	ventana addMorph: opcion3.	opcion4 := SimpleButtonMorph new label: (opcionesRespuestas at: 4);		position: 320@60.	opcion4 on: #mouseUp send: #seleccionarRespuesta: to: self.	opcion4 arguments: {(opcionesRespuestas at: 4)}.	ventana addMorph: opcion4.	"Botón para asignar ganador al jugador1 (para pruebas)"	botonGanador1 := SimpleButtonMorph new label: 'Asignar ganador: ', jugador1 nombre;		position: 50@200.	botonGanador1 on: #mouseUp send: #procesarGanadorManual:ventana: to: self.	botonGanador1 arguments: {jugador1. ventana}.	ventana addMorph: botonGanador1.	"Botón para asignar ganador al jugador2 (para pruebas)"	botonGanador2 := SimpleButtonMorph new label: 'Asignar ganador: ', jugador2 nombre;		position: 200@200.	botonGanador2 on: #mouseUp send: #procesarGanadorManual:ventana: to: self.	botonGanador2 arguments: {jugador2. ventana}.	ventana addMorph: botonGanador2.	"Mostrar la ventana en el mundo"	ventana openInWorld.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:25'!asignarTerritorioDe: perdedor a: winner	"Transfiere los territorios del perdedor al ganador y elimina al perdedor del juego"	winner agregarTerritorio: perdedor territorios.	jugadores remove: perdedor.	self verificarGanador.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:21'!solicitarNumeroJugadores	"Solicita al usuario el número de jugadores (máximo 10) y crea los jugadores"	| numeroJugadores |	numeroJugadores := UIManager default 		request: '¿Cuántos jugadores? (Máximo 10)' initialAnswer: '2'.	numeroJugadores asInteger > 10 ifTrue: [ 		UIManager default inform: 'Número máximo de jugadores es 10'; 		solicitarNumeroJugadores ].	jugadores := OrderedCollection new.	1 to: numeroJugadores asInteger do: [ :i | 		| jugador |		jugador := Jugador nuevoJugadorConNombre: (UIManager default request: 'Nombre del Jugador ', i asString).		jugadores add: jugador.	].! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:27'!iniciar	"Configura y comienza el juego."	"Inicializar preguntas y temas predefinidos desde un archivo JSON"	Pregunta cargarPreguntasDesdeArchivo: 'C:/Users/facun/OneDrive/Escritorio/test/preguntas.json'.	"Solicitar el número de jugadores"	self solicitarNumeroJugadores.	"Asignar temas a los jugadores de forma aleatoria"	self asignarTemas.	"Inicializar el tablero"	self inicializarTablero.	"Asignar territorios iniciales a los jugadores"	self asignarTerritorios.	"Iniciar el ciclo de juego"	self iniciarCicloDeJuego.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:43'!seleccionarRespuesta: unaRespuesta	"Guarda la respuesta seleccionada para el jugador actual"	respuestaSeleccionada := unaRespuesta.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:24'!elegirContrincante	"Permite al jugador actual elegir un contrincante para un duelo"	| contrincantes opciones contrincanteSeleccionado jugadorContrincante |	contrincantes := jugadores select: [:j | j ~= actualJugador].	opciones := (contrincantes collect: [:j | j nombre]) , {'Pasar turno'}.	contrincanteSeleccionado := UIManager default chooseFrom: opciones title: 'Elige un jugador para retar o pasa el turno'.	(contrincanteSeleccionado = 'Pasar turno') ifTrue: [^self].	jugadorContrincante := contrincantes detect: [:j | j nombre = contrincanteSeleccionado] ifNone: [nil].	jugadorContrincante ifNotNil: [		self dueloEntre: actualJugador y: jugadorContrincante	].! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:23'!iniciarCicloDeJuego	"Inicia el ciclo de turnos hasta que haya un ganador"	[self tieneGanador not] whileTrue: [		self siguienteTurno.	].	UIManager default inform: '¡El juego ha terminado!! El ganador es ', ganador nombre.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:25'!tieneGanador	"Devuelve verdadero si solo queda un jugador"	^jugadores size = 1.! !!Juego methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:23'!inicializarTablero	"Inicializa una estructura de tablero. Puede ser una matriz 4x4 o 5x5 para simplificar."	tablero := Array new: 4 withAll: (Array new: 4 withAll: nil).! !Object subclass: #Jugador	instanceVariableNames: 'nombre tema territorios'	classVariableNames: ''	poolDictionaries: ''	category: 'Juego-thefloor'!!Jugador methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:15'!territorios	"Getter para la colección de territorios del jugador"	^territorios.! !!Jugador methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:14'!nombre: unNombre	"Setter para el nombre del jugador"	nombre := unNombre.! !!Jugador methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:14'!territorios: unosTerritorios	"Setter para la colección de territorios del jugador"	territorios := unosTerritorios.! !!Jugador methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:14'!tema	"Getter para el tema del jugador"	^tema.! !!Jugador methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:14'!nombre	"Getter para el nombre del jugador"	^nombre.! !!Jugador methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:15'!asignarTerritorio: unTerritorio	"Inicializa el territorio del jugador"	territorios := OrderedCollection with: unTerritorio.! !!Jugador methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:14'!asignarTema: unTema	"Asigna un tema específico al jugador"	tema := unTema.! !!Jugador methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:15'!agregarTerritorio: nuevosTerritorios	"Agrega nuevos territorios a la colección de territorios del jugador"	territorios addAll: nuevosTerritorios.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Jugador class	instanceVariableNames: ''!!Jugador class methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:13'!nuevoJugadorConNombre: unNombre	"Crea y devuelve una nueva instancia de Jugador con el nombre dado"	| jugador |	jugador := self new.	jugador nombre: unNombre.	jugador territorios: OrderedCollection new.	^jugador.! !Object subclass: #Pregunta	instanceVariableNames: 'texto respuestasIncorrectas respuestaCorrecta'	classVariableNames: 'preguntasDisponibles'	poolDictionaries: ''	category: 'Juego-thefloor'!!Pregunta methodsFor: 'accessing' stamp: 'facu 11/14/2024 16:59'!respuestaCorrecta	^respuestaCorrecta.! !!Pregunta methodsFor: 'accessing' stamp: 'facu 11/14/2024 16:57'!respuestaCorrecta: correcta	respuestaCorrecta := correcta.! !!Pregunta methodsFor: 'accessing' stamp: 'facu 11/14/2024 16:57'!texto: unTexto	texto := unTexto.! !!Pregunta methodsFor: 'accessing' stamp: 'facu 11/14/2024 16:57'!respuestasIncorrectas: incorrectas	respuestasIncorrectas := incorrectas.! !!Pregunta methodsFor: 'accessing' stamp: 'facu 11/14/2024 16:58'!texto	^texto.! !!Pregunta methodsFor: 'accessing' stamp: 'facu 11/14/2024 16:59'!respuestasIncorrectas	^respuestasIncorrectas.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pregunta class	instanceVariableNames: ''!!Pregunta class methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 16:55'!cargarPreguntasDesdeArchivo: rutaArchivo	| jsonData preguntasPorTema contenido |		"Este método lee un archivo JSON y carga las preguntas por tema en preguntasDisponibles"	"Leer el contenido del archivo JSON como texto"	contenido := FileStream readOnlyFileNamed: rutaArchivo do: [ :stream | stream contents ].	"Decodificar el contenido JSON en un diccionario"	jsonData := NeoJSONReader fromString: contenido.	"Inicializar preguntasDisponibles si no lo está"	preguntasDisponibles ifNil: [preguntasDisponibles := Dictionary new].	"Organizar las preguntas por tema"	jsonData keysAndValuesDo: [ :tema :preguntasArray |		| preguntasTema |		preguntasTema := preguntasArray collect: [ :preguntaData |			Pregunta nuevaPregunta: (preguntaData at: 'texto')				respuestasIncorrectas: (preguntaData at: 'respuestasIncorrectas')				respuestaCorrecta: (preguntaData at: 'respuestaCorrecta')		].		preguntasDisponibles at: tema put: preguntasTema.	].! !!Pregunta class methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:06'!preguntasDisponibles	"Devuelve la variable de clase preguntasDisponibles"	preguntasDisponibles ifNil: [preguntasDisponibles := Dictionary new].	^preguntasDisponibles.! !!Pregunta class methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 16:56'!nuevaPregunta: texto respuestasIncorrectas: incorrectas respuestaCorrecta: correcta	| pregunta |	pregunta := self new.	pregunta texto: texto.	pregunta respuestasIncorrectas: incorrectas.	pregunta respuestaCorrecta: correcta.	^pregunta.! !Object subclass: #Tema	instanceVariableNames: 'nombre preguntas'	classVariableNames: ''	poolDictionaries: ''	category: 'Juego-thefloor'!!Tema methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:11'!preguntas	"Getter para la colección de preguntas del tema"	^preguntas.! !!Tema methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:11'!preguntas: unasPreguntas	"Setter para las preguntas del tema"	preguntas := unasPreguntas.! !!Tema methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:11'!nombre: unNombre	"Setter para el nombre del tema"	nombre := unNombre.! !!Tema methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:11'!preguntaAleatoria	"Devuelve una pregunta aleatoria del tema"	^preguntas isEmpty ifFalse: [preguntas atRandom].! !!Tema methodsFor: 'accessing' stamp: 'facu 11/14/2024 17:11'!nombre	"Getter para el nombre del tema"	^nombre.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Tema class	instanceVariableNames: ''!!Tema class methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:10'!nuevoTemaConNombre: unNombre	"Inicializa un nuevo tema con el nombre dado y asigna las preguntas correspondientes"	| tema preguntasTema |	preguntasTema := Pregunta preguntasDisponibles at: unNombre ifAbsent: [#()].	tema := self new.	tema nombre: unNombre.	tema preguntas: preguntasTema.	^tema.! !!Tema class methodsFor: 'as yet unclassified' stamp: 'facu 11/14/2024 17:10'!temasDisponibles	"Devuelve una colección de los nombres de los temas disponibles en preguntasDisponibles"	^Pregunta preguntasDisponibles keys.! !